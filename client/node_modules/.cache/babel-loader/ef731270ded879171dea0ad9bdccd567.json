{"ast":null,"code":"var Hand = require(\"./hand\"),\n    Pointable = require(\"./pointable\"),\n    glMatrix = require(\"gl-matrix\"),\n    mat3 = glMatrix.mat3,\n    vec3 = glMatrix.vec3,\n    InteractionBox = require(\"./interaction_box\"),\n    Finger = require('./finger');\n/**\n * Constructs a Frame object.\n *\n * Frame instances created with this constructor are invalid.\n * Get valid Frame objects by calling the\n * [Controller.frame]{@link Leap.Controller#frame}() function.\n *<C-D-Space>\n * @class Frame\n * @memberof Leap\n * @classdesc\n * The Frame class represents a set of hand and finger tracking data detected\n * in a single frame.\n *\n * The Leap detects hands, fingers within the tracking area, reporting\n * their positions, orientations and motions in frames at the Leap frame rate.\n *\n * Access Frame objects using the [Controller.frame]{@link Leap.Controller#frame}() function.\n */\n\n\nvar Frame = module.exports = function (data) {\n  /**\n   * Reports whether this Frame instance is valid.\n   *\n   * A valid Frame is one generated by the Controller object that contains\n   * tracking data for all detected entities. An invalid Frame contains no\n   * actual tracking data, but you can call its functions without risk of a\n   * undefined object exception. The invalid Frame mechanism makes it more\n   * convenient to track individual data across the frame history. For example,\n   * you can invoke:\n   *\n   * ```javascript\n   * var finger = controller.frame(n).finger(fingerID);\n   * ```\n   *\n   * for an arbitrary Frame history value, \"n\", without first checking whether\n   * frame(n) returned a null object. (You should still check that the\n   * returned Finger instance is valid.)\n   *\n   * @member valid\n   * @memberof Leap.Frame.prototype\n   * @type {Boolean}\n   */\n  this.valid = true;\n  /**\n   * A unique ID for this Frame. Consecutive frames processed by the Leap\n   * have consecutive increasing values.\n   * @member id\n   * @memberof Leap.Frame.prototype\n   * @type {String}\n   */\n\n  this.id = data.id;\n  /**\n   * The frame capture time in microseconds elapsed since the Leap started.\n   * @member timestamp\n   * @memberof Leap.Frame.prototype\n   * @type {number}\n   */\n\n  this.timestamp = data.timestamp;\n  /**\n   * The list of Hand objects detected in this frame, given in arbitrary order.\n   * The list can be empty if no hands are detected.\n   *\n   * @member hands[]\n   * @memberof Leap.Frame.prototype\n   * @type {Leap.Hand}\n   */\n\n  this.hands = [];\n  this.handsMap = {};\n  /**\n   * The list of Pointable objects (fingers) detected in this frame,\n   * given in arbitrary order. The list can be empty if no fingers are\n   * detected.\n   *\n   * @member pointables[]\n   * @memberof Leap.Frame.prototype\n   * @type {Leap.Pointable}\n   */\n\n  this.pointables = [];\n  /**\n   * The list of Finger objects detected in this frame, given in arbitrary order.\n   * The list can be empty if no fingers are detected.\n   * @member fingers[]\n   * @memberof Leap.Frame.prototype\n   * @type {Leap.Pointable}\n   */\n\n  this.fingers = [];\n  /**\n   * The InteractionBox associated with the current frame.\n   *\n   * @member interactionBox\n   * @memberof Leap.Frame.prototype\n   * @type {Leap.InteractionBox}\n   */\n\n  if (data.interactionBox) {\n    this.interactionBox = new InteractionBox(data.interactionBox);\n  }\n\n  this.pointablesMap = {};\n  this._translation = data.t;\n\n  function flattenDeep(arr) {\n    return Array.isArray(arr) ? arr.reduce(function (a, b) {\n      return a.concat(flattenDeep(b));\n    }, []) : [arr];\n  }\n\n  this._rotation = flattenDeep(data.r);\n  this._scaleFactor = data.s;\n  this.data = data;\n  this.type = 'frame'; // used by event emitting\n\n  this.currentFrameRate = data.currentFrameRate;\n  this.postprocessData(data);\n};\n\nFrame.prototype.postprocessData = function (data) {\n  if (!data) {\n    data = this.data;\n  }\n\n  for (var handIdx = 0, handCount = data.hands.length; handIdx != handCount; handIdx++) {\n    var hand = new Hand(data.hands[handIdx]);\n    hand.frame = this;\n    this.hands.push(hand);\n    this.handsMap[hand.id] = hand;\n  }\n\n  var sortBy = function (key) {\n    return function (a, b) {\n      return a[key] > b[key] ? 1 : b[key] > a[key] ? -1 : 0;\n    };\n  };\n\n  data.pointables.sort(sortBy(\"id\"));\n\n  for (var pointableIdx = 0, pointableCount = data.pointables.length; pointableIdx != pointableCount; pointableIdx++) {\n    var pointableData = data.pointables[pointableIdx];\n    var pointable = pointableData.dipPosition ? new Finger(pointableData) : new Pointable(pointableData);\n    pointable.frame = this;\n    this.addPointable(pointable);\n  }\n};\n/**\n * Adds data from a pointable element into the pointablesMap; \n * also adds the pointable to the frame.handsMap hand to which it belongs,\n * and to the hand's fingers map.\n * \n * @param pointable {Object} a Pointable\n */\n\n\nFrame.prototype.addPointable = function (pointable) {\n  this.pointables.push(pointable);\n  this.pointablesMap[pointable.id] = pointable;\n  this.fingers.push(pointable);\n\n  if (pointable.handId !== undefined && this.handsMap.hasOwnProperty(pointable.handId)) {\n    var hand = this.handsMap[pointable.handId];\n    hand.pointables.push(pointable);\n    hand.fingers.push(pointable);\n\n    switch (pointable.type) {\n      case 0:\n        hand.thumb = pointable;\n        break;\n\n      case 1:\n        hand.indexFinger = pointable;\n        break;\n\n      case 2:\n        hand.middleFinger = pointable;\n        break;\n\n      case 3:\n        hand.ringFinger = pointable;\n        break;\n\n      case 4:\n        hand.pinky = pointable;\n        break;\n    }\n  }\n};\n/**\n * The Pointable object with the specified ID in this frame.\n *\n * Use the Frame pointable() function to retrieve the Pointable object from\n * this frame using an ID value obtained from a previous frame.\n * This function always returns a Pointable object, but if no finger\n * with the specified ID is present, an invalid Pointable object is returned.\n *\n * Note that ID values persist across frames, but only until tracking of a\n * particular object is lost. If tracking of a finger is lost and subsequently\n * regained, the new Pointable object representing that finger may have\n * a different ID than that representing the finger in an earlier frame.\n *\n * @method pointable\n * @memberof Leap.Frame.prototype\n * @param {String} id The ID value of a Pointable object from a previous frame.\n * @returns {Leap.Pointable} The Pointable object with\n * the matching ID if one exists in this frame;\n * otherwise, an invalid Pointable object is returned.\n */\n\n\nFrame.prototype.pointable = function (id) {\n  return this.pointablesMap[id] || Pointable.Invalid;\n};\n/**\n * The finger with the specified ID in this frame.\n *\n * Use the Frame finger() function to retrieve the finger from\n * this frame using an ID value obtained from a previous frame.\n * This function always returns a Finger object, but if no finger\n * with the specified ID is present, an invalid Pointable object is returned.\n *\n * Note that ID values persist across frames, but only until tracking of a\n * particular object is lost. If tracking of a finger is lost and subsequently\n * regained, the new Pointable object representing that physical finger may have\n * a different ID than that representing the finger in an earlier frame.\n *\n * @method finger\n * @memberof Leap.Frame.prototype\n * @param {String} id The ID value of a finger from a previous frame.\n * @returns {Leap.Pointable} The finger with the\n * matching ID if one exists in this frame; otherwise, an invalid Pointable\n * object is returned.\n */\n\n\nFrame.prototype.finger = function (id) {\n  return this.pointable(id);\n};\n/**\n * The Hand object with the specified ID in this frame.\n *\n * Use the Frame hand() function to retrieve the Hand object from\n * this frame using an ID value obtained from a previous frame.\n * This function always returns a Hand object, but if no hand\n * with the specified ID is present, an invalid Hand object is returned.\n *\n * Note that ID values persist across frames, but only until tracking of a\n * particular object is lost. If tracking of a hand is lost and subsequently\n * regained, the new Hand object representing that physical hand may have\n * a different ID than that representing the physical hand in an earlier frame.\n *\n * @method hand\n * @memberof Leap.Frame.prototype\n * @param {String} id The ID value of a Hand object from a previous frame.\n * @returns {Leap.Hand} The Hand object with the matching\n * ID if one exists in this frame; otherwise, an invalid Hand object is returned.\n */\n\n\nFrame.prototype.hand = function (id) {\n  return this.handsMap[id] || Hand.Invalid;\n};\n/**\n * The angle of rotation around the rotation axis derived from the overall\n * rotational motion between the current frame and the specified frame.\n *\n * The returned angle is expressed in radians measured clockwise around\n * the rotation axis (using the right-hand rule) between the start and end frames.\n * The value is always between 0 and pi radians (0 and 180 degrees).\n *\n * The Leap derives frame rotation from the relative change in position and\n * orientation of all objects detected in the field of view.\n *\n * If either this frame or sinceFrame is an invalid Frame object, then the\n * angle of rotation is zero.\n *\n * @method rotationAngle\n * @memberof Leap.Frame.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @param {number[]} [axis] The axis to measure rotation around.\n * @returns {number} A positive value containing the heuristically determined\n * rotational change between the current frame and that specified in the sinceFrame parameter.\n */\n\n\nFrame.prototype.rotationAngle = function (sinceFrame, axis) {\n  if (!this.valid || !sinceFrame.valid) return 0.0;\n  var rot = this.rotationMatrix(sinceFrame);\n  var cs = (rot[0] + rot[4] + rot[8] - 1.0) * 0.5;\n  var angle = Math.acos(cs);\n  angle = isNaN(angle) ? 0.0 : angle;\n\n  if (axis !== undefined) {\n    var rotAxis = this.rotationAxis(sinceFrame);\n    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));\n  }\n\n  return angle;\n};\n/**\n * The axis of rotation derived from the overall rotational motion between\n * the current frame and the specified frame.\n *\n * The returned direction vector is normalized.\n *\n * The Leap derives frame rotation from the relative change in position and\n * orientation of all objects detected in the field of view.\n *\n * If either this frame or sinceFrame is an invalid Frame object, or if no\n * rotation is detected between the two frames, a zero vector is returned.\n *\n * @method rotationAxis\n * @memberof Leap.Frame.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @returns {number[]} A normalized direction vector representing the axis of the heuristically determined\n * rotational change between the current frame and that specified in the sinceFrame parameter.\n */\n\n\nFrame.prototype.rotationAxis = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  return vec3.normalize(vec3.create(), [this._rotation[7] - sinceFrame._rotation[5], this._rotation[2] - sinceFrame._rotation[6], this._rotation[3] - sinceFrame._rotation[1]]);\n};\n/**\n * The transform matrix expressing the rotation derived from the overall\n * rotational motion between the current frame and the specified frame.\n *\n * The Leap derives frame rotation from the relative change in position and\n * orientation of all objects detected in the field of view.\n *\n * If either this frame or sinceFrame is an invalid Frame object, then\n * this method returns an identity matrix.\n *\n * @method rotationMatrix\n * @memberof Leap.Frame.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @returns {number[]} A transformation matrix containing the heuristically determined\n * rotational change between the current frame and that specified in the sinceFrame parameter.\n */\n\n\nFrame.prototype.rotationMatrix = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return mat3.create();\n  var transpose = mat3.transpose(mat3.create(), this._rotation);\n  return mat3.multiply(mat3.create(), sinceFrame._rotation, transpose);\n};\n/**\n * The scale factor derived from the overall motion between the current frame and the specified frame.\n *\n * The scale factor is always positive. A value of 1.0 indicates no scaling took place.\n * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.\n *\n * The Leap derives scaling from the relative inward or outward motion of all\n * objects detected in the field of view (independent of translation and rotation).\n *\n * If either this frame or sinceFrame is an invalid Frame object, then this method returns 1.0.\n *\n * @method scaleFactor\n * @memberof Leap.Frame.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.\n * @returns {number} A positive value representing the heuristically determined\n * scaling change ratio between the current frame and that specified in the sinceFrame parameter.\n */\n\n\nFrame.prototype.scaleFactor = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return 1.0;\n  return Math.exp(this._scaleFactor - sinceFrame._scaleFactor);\n};\n/**\n * The change of position derived from the overall linear motion between the\n * current frame and the specified frame.\n *\n * The returned translation vector provides the magnitude and direction of the\n * movement in millimeters.\n *\n * The Leap derives frame translation from the linear motion of all objects\n * detected in the field of view.\n *\n * If either this frame or sinceFrame is an invalid Frame object, then this\n * method returns a zero vector.\n *\n * @method translation\n * @memberof Leap.Frame.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.\n * @returns {number[]} A vector representing the heuristically determined change in\n * position of all objects between the current frame and that specified in the sinceFrame parameter.\n */\n\n\nFrame.prototype.translation = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  return vec3.subtract(vec3.create(), this._translation, sinceFrame._translation);\n};\n/**\n * A string containing a brief, human readable description of the Frame object.\n *\n * @method toString\n * @memberof Leap.Frame.prototype\n * @returns {String} A brief description of this frame.\n */\n\n\nFrame.prototype.toString = function () {\n  var str = \"Frame [ id:\" + this.id + \" | timestamp:\" + this.timestamp + \" | Hand count:(\" + this.hands.length + \") | Pointable count:(\" + this.pointables.length + \")\";\n  str += \" ]\";\n  return str;\n};\n/**\n * Returns a JSON-formatted string containing the hands, pointables\n * in this frame.\n *\n * @method dump\n * @memberof Leap.Frame.prototype\n * @returns {String} A JSON-formatted string.\n */\n\n\nFrame.prototype.dump = function () {\n  var out = '';\n  out += \"Frame Info:<br/>\";\n  out += this.toString();\n  out += \"<br/><br/>Hands:<br/>\";\n\n  for (var handIdx = 0, handCount = this.hands.length; handIdx != handCount; handIdx++) {\n    out += \"  \" + this.hands[handIdx].toString() + \"<br/>\";\n  }\n\n  out += \"<br/><br/>Pointables:<br/>\";\n\n  for (var pointableIdx = 0, pointableCount = this.pointables.length; pointableIdx != pointableCount; pointableIdx++) {\n    out += \"  \" + this.pointables[pointableIdx].toString() + \"<br/>\";\n  }\n\n  out += \"<br/><br/>Raw JSON:<br/>\";\n  out += JSON.stringify(this.data);\n  return out;\n};\n/**\n * An invalid Frame object.\n *\n * You can use this invalid Frame in comparisons testing\n * whether a given Frame instance is valid or invalid. (You can also check the\n * [Frame.valid]{@link Leap.Frame#valid} property.)\n *\n * @static\n * @type {Leap.Frame}\n * @name Invalid\n * @memberof Leap.Frame\n */\n\n\nFrame.Invalid = {\n  valid: false,\n  hands: [],\n  fingers: [],\n  pointables: [],\n  pointable: function () {\n    return Pointable.Invalid;\n  },\n  finger: function () {\n    return Pointable.Invalid;\n  },\n  hand: function () {\n    return Hand.Invalid;\n  },\n  toString: function () {\n    return \"invalid frame\";\n  },\n  dump: function () {\n    return this.toString();\n  },\n  rotationAngle: function () {\n    return 0.0;\n  },\n  rotationMatrix: function () {\n    return mat3.create();\n  },\n  rotationAxis: function () {\n    return vec3.create();\n  },\n  scaleFactor: function () {\n    return 1.0;\n  },\n  translation: function () {\n    return vec3.create();\n  }\n};","map":{"version":3,"sources":["/Users/stevdiaz/Desktop/MIT SPRING 2021/6835/6835Final/pic/node_modules/leapjs/lib/frame.js"],"names":["Hand","require","Pointable","glMatrix","mat3","vec3","InteractionBox","Finger","Frame","module","exports","data","valid","id","timestamp","hands","handsMap","pointables","fingers","interactionBox","pointablesMap","_translation","t","flattenDeep","arr","Array","isArray","reduce","a","b","concat","_rotation","r","_scaleFactor","s","type","currentFrameRate","postprocessData","prototype","handIdx","handCount","length","hand","frame","push","sortBy","key","sort","pointableIdx","pointableCount","pointableData","pointable","dipPosition","addPointable","handId","undefined","hasOwnProperty","thumb","indexFinger","middleFinger","ringFinger","pinky","Invalid","finger","rotationAngle","sinceFrame","axis","rot","rotationMatrix","cs","angle","Math","acos","isNaN","rotAxis","rotationAxis","dot","normalize","create","transpose","multiply","scaleFactor","exp","translation","subtract","toString","str","dump","out","JSON","stringify"],"mappings":"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","sourcesContent":["var Hand = require(\"./hand\")\n  , Pointable = require(\"./pointable\")\n  , glMatrix = require(\"gl-matrix\")\n  , mat3 = glMatrix.mat3\n  , vec3 = glMatrix.vec3\n  , InteractionBox = require(\"./interaction_box\")\n  , Finger = require('./finger');\n\n/**\n * Constructs a Frame object.\n *\n * Frame instances created with this constructor are invalid.\n * Get valid Frame objects by calling the\n * [Controller.frame]{@link Leap.Controller#frame}() function.\n *<C-D-Space>\n * @class Frame\n * @memberof Leap\n * @classdesc\n * The Frame class represents a set of hand and finger tracking data detected\n * in a single frame.\n *\n * The Leap detects hands, fingers within the tracking area, reporting\n * their positions, orientations and motions in frames at the Leap frame rate.\n *\n * Access Frame objects using the [Controller.frame]{@link Leap.Controller#frame}() function.\n */\nvar Frame = module.exports = function(data) {\n  /**\n   * Reports whether this Frame instance is valid.\n   *\n   * A valid Frame is one generated by the Controller object that contains\n   * tracking data for all detected entities. An invalid Frame contains no\n   * actual tracking data, but you can call its functions without risk of a\n   * undefined object exception. The invalid Frame mechanism makes it more\n   * convenient to track individual data across the frame history. For example,\n   * you can invoke:\n   *\n   * ```javascript\n   * var finger = controller.frame(n).finger(fingerID);\n   * ```\n   *\n   * for an arbitrary Frame history value, \"n\", without first checking whether\n   * frame(n) returned a null object. (You should still check that the\n   * returned Finger instance is valid.)\n   *\n   * @member valid\n   * @memberof Leap.Frame.prototype\n   * @type {Boolean}\n   */\n  this.valid = true;\n  /**\n   * A unique ID for this Frame. Consecutive frames processed by the Leap\n   * have consecutive increasing values.\n   * @member id\n   * @memberof Leap.Frame.prototype\n   * @type {String}\n   */\n  this.id = data.id;\n  /**\n   * The frame capture time in microseconds elapsed since the Leap started.\n   * @member timestamp\n   * @memberof Leap.Frame.prototype\n   * @type {number}\n   */\n  this.timestamp = data.timestamp;\n  /**\n   * The list of Hand objects detected in this frame, given in arbitrary order.\n   * The list can be empty if no hands are detected.\n   *\n   * @member hands[]\n   * @memberof Leap.Frame.prototype\n   * @type {Leap.Hand}\n   */\n  this.hands = [];\n  this.handsMap = {};\n  /**\n   * The list of Pointable objects (fingers) detected in this frame,\n   * given in arbitrary order. The list can be empty if no fingers are\n   * detected.\n   *\n   * @member pointables[]\n   * @memberof Leap.Frame.prototype\n   * @type {Leap.Pointable}\n   */\n  this.pointables = [];\n  /**\n   * The list of Finger objects detected in this frame, given in arbitrary order.\n   * The list can be empty if no fingers are detected.\n   * @member fingers[]\n   * @memberof Leap.Frame.prototype\n   * @type {Leap.Pointable}\n   */\n  this.fingers = [];\n\n  /**\n   * The InteractionBox associated with the current frame.\n   *\n   * @member interactionBox\n   * @memberof Leap.Frame.prototype\n   * @type {Leap.InteractionBox}\n   */\n  if (data.interactionBox) {\n    this.interactionBox = new InteractionBox(data.interactionBox);\n  }\n  this.pointablesMap = {};\n  this._translation = data.t;\n  function flattenDeep(arr) {\n    return Array.isArray(arr)\n      ? arr.reduce(function (a, b) { return a.concat(flattenDeep(b)) }, [])\n      : [arr];\n  }\n  this._rotation    = flattenDeep(data.r);\n  this._scaleFactor = data.s;\n  this.data = data;\n  this.type = 'frame'; // used by event emitting\n  this.currentFrameRate = data.currentFrameRate;\n\n  this.postprocessData(data);\n};\n\nFrame.prototype.postprocessData = function(data){\n  if (!data) {\n    data = this.data;\n  }\n\n  for (var handIdx = 0, handCount = data.hands.length; handIdx != handCount; handIdx++) {\n    var hand = new Hand(data.hands[handIdx]);\n    hand.frame = this;\n    this.hands.push(hand);\n    this.handsMap[hand.id] = hand;\n  }\n\n  var sortBy = function(key) {\n    return function (a, b) { return (a[key] > b[key]) ? 1 : ((b[key] > a[key]) ? -1 : 0) };\n  };\n\n  data.pointables.sort(sortBy(\"id\"));\n\n  for (var pointableIdx = 0, pointableCount = data.pointables.length; pointableIdx != pointableCount; pointableIdx++) {\n    var pointableData = data.pointables[pointableIdx];\n    var pointable = pointableData.dipPosition ? new Finger(pointableData) : new Pointable(pointableData);\n    pointable.frame = this;\n    this.addPointable(pointable);\n  }\n};\n\n/**\n * Adds data from a pointable element into the pointablesMap; \n * also adds the pointable to the frame.handsMap hand to which it belongs,\n * and to the hand's fingers map.\n * \n * @param pointable {Object} a Pointable\n */\nFrame.prototype.addPointable = function (pointable) {\n  this.pointables.push(pointable);\n  this.pointablesMap[pointable.id] = pointable;\n  (this.fingers).push(pointable);\n  if (pointable.handId !== undefined && this.handsMap.hasOwnProperty(pointable.handId)) {\n    var hand = this.handsMap[pointable.handId];\n    hand.pointables.push(pointable);\n    (hand.fingers).push(pointable);\n    switch (pointable.type){\n      case 0:\n        hand.thumb = pointable;\n        break;\n      case 1:\n        hand.indexFinger = pointable;\n        break;\n      case 2:\n        hand.middleFinger = pointable;\n        break;\n      case 3:\n        hand.ringFinger = pointable;\n        break;\n      case 4:\n        hand.pinky = pointable;\n        break;\n    }\n  }\n};\n\n/**\n * The Pointable object with the specified ID in this frame.\n *\n * Use the Frame pointable() function to retrieve the Pointable object from\n * this frame using an ID value obtained from a previous frame.\n * This function always returns a Pointable object, but if no finger\n * with the specified ID is present, an invalid Pointable object is returned.\n *\n * Note that ID values persist across frames, but only until tracking of a\n * particular object is lost. If tracking of a finger is lost and subsequently\n * regained, the new Pointable object representing that finger may have\n * a different ID than that representing the finger in an earlier frame.\n *\n * @method pointable\n * @memberof Leap.Frame.prototype\n * @param {String} id The ID value of a Pointable object from a previous frame.\n * @returns {Leap.Pointable} The Pointable object with\n * the matching ID if one exists in this frame;\n * otherwise, an invalid Pointable object is returned.\n */\nFrame.prototype.pointable = function(id) {\n  return this.pointablesMap[id] || Pointable.Invalid;\n};\n\n/**\n * The finger with the specified ID in this frame.\n *\n * Use the Frame finger() function to retrieve the finger from\n * this frame using an ID value obtained from a previous frame.\n * This function always returns a Finger object, but if no finger\n * with the specified ID is present, an invalid Pointable object is returned.\n *\n * Note that ID values persist across frames, but only until tracking of a\n * particular object is lost. If tracking of a finger is lost and subsequently\n * regained, the new Pointable object representing that physical finger may have\n * a different ID than that representing the finger in an earlier frame.\n *\n * @method finger\n * @memberof Leap.Frame.prototype\n * @param {String} id The ID value of a finger from a previous frame.\n * @returns {Leap.Pointable} The finger with the\n * matching ID if one exists in this frame; otherwise, an invalid Pointable\n * object is returned.\n */\nFrame.prototype.finger = function(id) {\n  return this.pointable(id);\n};\n\n/**\n * The Hand object with the specified ID in this frame.\n *\n * Use the Frame hand() function to retrieve the Hand object from\n * this frame using an ID value obtained from a previous frame.\n * This function always returns a Hand object, but if no hand\n * with the specified ID is present, an invalid Hand object is returned.\n *\n * Note that ID values persist across frames, but only until tracking of a\n * particular object is lost. If tracking of a hand is lost and subsequently\n * regained, the new Hand object representing that physical hand may have\n * a different ID than that representing the physical hand in an earlier frame.\n *\n * @method hand\n * @memberof Leap.Frame.prototype\n * @param {String} id The ID value of a Hand object from a previous frame.\n * @returns {Leap.Hand} The Hand object with the matching\n * ID if one exists in this frame; otherwise, an invalid Hand object is returned.\n */\nFrame.prototype.hand = function(id) {\n  return this.handsMap[id] || Hand.Invalid;\n};\n\n/**\n * The angle of rotation around the rotation axis derived from the overall\n * rotational motion between the current frame and the specified frame.\n *\n * The returned angle is expressed in radians measured clockwise around\n * the rotation axis (using the right-hand rule) between the start and end frames.\n * The value is always between 0 and pi radians (0 and 180 degrees).\n *\n * The Leap derives frame rotation from the relative change in position and\n * orientation of all objects detected in the field of view.\n *\n * If either this frame or sinceFrame is an invalid Frame object, then the\n * angle of rotation is zero.\n *\n * @method rotationAngle\n * @memberof Leap.Frame.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @param {number[]} [axis] The axis to measure rotation around.\n * @returns {number} A positive value containing the heuristically determined\n * rotational change between the current frame and that specified in the sinceFrame parameter.\n */\nFrame.prototype.rotationAngle = function(sinceFrame, axis) {\n  if (!this.valid || !sinceFrame.valid) return 0.0;\n\n  var rot = this.rotationMatrix(sinceFrame);\n  var cs = (rot[0] + rot[4] + rot[8] - 1.0)*0.5;\n  var angle = Math.acos(cs);\n  angle = isNaN(angle) ? 0.0 : angle;\n\n  if (axis !== undefined) {\n    var rotAxis = this.rotationAxis(sinceFrame);\n    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));\n  }\n\n  return angle;\n};\n\n/**\n * The axis of rotation derived from the overall rotational motion between\n * the current frame and the specified frame.\n *\n * The returned direction vector is normalized.\n *\n * The Leap derives frame rotation from the relative change in position and\n * orientation of all objects detected in the field of view.\n *\n * If either this frame or sinceFrame is an invalid Frame object, or if no\n * rotation is detected between the two frames, a zero vector is returned.\n *\n * @method rotationAxis\n * @memberof Leap.Frame.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @returns {number[]} A normalized direction vector representing the axis of the heuristically determined\n * rotational change between the current frame and that specified in the sinceFrame parameter.\n */\nFrame.prototype.rotationAxis = function(sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  return vec3.normalize(vec3.create(), [\n    this._rotation[7] - sinceFrame._rotation[5],\n    this._rotation[2] - sinceFrame._rotation[6],\n    this._rotation[3] - sinceFrame._rotation[1]\n  ]);\n}\n\n/**\n * The transform matrix expressing the rotation derived from the overall\n * rotational motion between the current frame and the specified frame.\n *\n * The Leap derives frame rotation from the relative change in position and\n * orientation of all objects detected in the field of view.\n *\n * If either this frame or sinceFrame is an invalid Frame object, then\n * this method returns an identity matrix.\n *\n * @method rotationMatrix\n * @memberof Leap.Frame.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @returns {number[]} A transformation matrix containing the heuristically determined\n * rotational change between the current frame and that specified in the sinceFrame parameter.\n */\nFrame.prototype.rotationMatrix = function(sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return mat3.create();\n  var transpose = mat3.transpose(mat3.create(), this._rotation)\n  return mat3.multiply(mat3.create(), sinceFrame._rotation, transpose);\n}\n\n/**\n * The scale factor derived from the overall motion between the current frame and the specified frame.\n *\n * The scale factor is always positive. A value of 1.0 indicates no scaling took place.\n * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.\n *\n * The Leap derives scaling from the relative inward or outward motion of all\n * objects detected in the field of view (independent of translation and rotation).\n *\n * If either this frame or sinceFrame is an invalid Frame object, then this method returns 1.0.\n *\n * @method scaleFactor\n * @memberof Leap.Frame.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.\n * @returns {number} A positive value representing the heuristically determined\n * scaling change ratio between the current frame and that specified in the sinceFrame parameter.\n */\nFrame.prototype.scaleFactor = function(sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return 1.0;\n  return Math.exp(this._scaleFactor - sinceFrame._scaleFactor);\n}\n\n/**\n * The change of position derived from the overall linear motion between the\n * current frame and the specified frame.\n *\n * The returned translation vector provides the magnitude and direction of the\n * movement in millimeters.\n *\n * The Leap derives frame translation from the linear motion of all objects\n * detected in the field of view.\n *\n * If either this frame or sinceFrame is an invalid Frame object, then this\n * method returns a zero vector.\n *\n * @method translation\n * @memberof Leap.Frame.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.\n * @returns {number[]} A vector representing the heuristically determined change in\n * position of all objects between the current frame and that specified in the sinceFrame parameter.\n */\nFrame.prototype.translation = function(sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  return vec3.subtract(vec3.create(), this._translation, sinceFrame._translation);\n}\n\n/**\n * A string containing a brief, human readable description of the Frame object.\n *\n * @method toString\n * @memberof Leap.Frame.prototype\n * @returns {String} A brief description of this frame.\n */\nFrame.prototype.toString = function() {\n  var str = \"Frame [ id:\"+this.id+\" | timestamp:\"+this.timestamp+\" | Hand count:(\"+this.hands.length+\") | Pointable count:(\"+this.pointables.length+\")\";\n  str += \" ]\";\n  return str;\n}\n\n/**\n * Returns a JSON-formatted string containing the hands, pointables\n * in this frame.\n *\n * @method dump\n * @memberof Leap.Frame.prototype\n * @returns {String} A JSON-formatted string.\n */\nFrame.prototype.dump = function() {\n  var out = '';\n  out += \"Frame Info:<br/>\";\n  out += this.toString();\n  out += \"<br/><br/>Hands:<br/>\"\n  for (var handIdx = 0, handCount = this.hands.length; handIdx != handCount; handIdx++) {\n    out += \"  \"+ this.hands[handIdx].toString() + \"<br/>\";\n  }\n  out += \"<br/><br/>Pointables:<br/>\";\n  for (var pointableIdx = 0, pointableCount = this.pointables.length; pointableIdx != pointableCount; pointableIdx++) {\n      out += \"  \"+ this.pointables[pointableIdx].toString() + \"<br/>\";\n  }\n  out += \"<br/><br/>Raw JSON:<br/>\";\n  out += JSON.stringify(this.data);\n  return out;\n}\n\n/**\n * An invalid Frame object.\n *\n * You can use this invalid Frame in comparisons testing\n * whether a given Frame instance is valid or invalid. (You can also check the\n * [Frame.valid]{@link Leap.Frame#valid} property.)\n *\n * @static\n * @type {Leap.Frame}\n * @name Invalid\n * @memberof Leap.Frame\n */\nFrame.Invalid = {\n  valid: false,\n  hands: [],\n  fingers: [],\n  pointables: [],\n  pointable: function() { return Pointable.Invalid },\n  finger: function() { return Pointable.Invalid },\n  hand: function() { return Hand.Invalid },\n  toString: function() { return \"invalid frame\" },\n  dump: function() { return this.toString() },\n  rotationAngle: function() { return 0.0; },\n  rotationMatrix: function() { return mat3.create(); },\n  rotationAxis: function() { return vec3.create(); },\n  scaleFactor: function() { return 1.0; },\n  translation: function() { return vec3.create(); }\n};\n"]},"metadata":{},"sourceType":"script"}