{"ast":null,"code":"var Pipeline = module.exports = function (controller) {\n  this.steps = [];\n  this.controller = controller;\n};\n\nPipeline.prototype.addStep = function (step) {\n  this.steps.push(step);\n};\n\nPipeline.prototype.run = function (frame) {\n  var stepsLength = this.steps.length;\n\n  for (var i = 0; i != stepsLength; i++) {\n    if (!frame) break;\n    frame = this.steps[i](frame);\n  }\n\n  return frame;\n};\n\nPipeline.prototype.removeStep = function (step) {\n  var index = this.steps.indexOf(step);\n  if (index === -1) throw \"Step not found in pipeline\";\n  this.steps.splice(index, 1);\n};\n/*\n * Wraps a plugin callback method in method which can be run inside the pipeline.\n * This wrapper method loops the callback over objects within the frame as is appropriate,\n * calling the callback for each in turn.\n *\n * @method createStepFunction\n * @memberOf Leap.Controller.prototype\n * @param {Controller} The controller on which the callback is called.\n * @param {String} type What frame object the callback is run for and receives.\n *       Can be one of 'frame', 'finger', 'hand', 'pointable'\n * @param {function} callback The method which will be run inside the pipeline loop.  Receives one argument, such as a hand.\n * @private\n */\n\n\nPipeline.prototype.addWrappedStep = function (type, callback) {\n  var controller = this.controller,\n      step = function (frame) {\n    var dependencies, i, len;\n    dependencies = type == 'frame' ? [frame] : frame[type + 's'] || [];\n\n    for (i = 0, len = dependencies.length; i < len; i++) {\n      callback.call(controller, dependencies[i]);\n    }\n\n    return frame;\n  };\n\n  this.addStep(step);\n  return step;\n};","map":{"version":3,"sources":["/Users/stevdiaz/Desktop/MIT SPRING 2021/6835/6835Final/pic/node_modules/leapjs/lib/pipeline.js"],"names":["Pipeline","module","exports","controller","steps","prototype","addStep","step","push","run","frame","stepsLength","length","i","removeStep","index","indexOf","splice","addWrappedStep","type","callback","dependencies","len","call"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,OAAP,GAAiB,UAAUC,UAAV,EAAsB;AACpD,OAAKC,KAAL,GAAa,EAAb;AACA,OAAKD,UAAL,GAAkBA,UAAlB;AACD,CAHD;;AAKAH,QAAQ,CAACK,SAAT,CAAmBC,OAAnB,GAA6B,UAAUC,IAAV,EAAgB;AAC3C,OAAKH,KAAL,CAAWI,IAAX,CAAgBD,IAAhB;AACD,CAFD;;AAIAP,QAAQ,CAACK,SAAT,CAAmBI,GAAnB,GAAyB,UAAUC,KAAV,EAAiB;AACxC,MAAIC,WAAW,GAAG,KAAKP,KAAL,CAAWQ,MAA7B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIF,WAArB,EAAkCE,CAAC,EAAnC,EAAuC;AACrC,QAAI,CAACH,KAAL,EAAY;AACZA,IAAAA,KAAK,GAAG,KAAKN,KAAL,CAAWS,CAAX,EAAcH,KAAd,CAAR;AACD;;AACD,SAAOA,KAAP;AACD,CAPD;;AASAV,QAAQ,CAACK,SAAT,CAAmBS,UAAnB,GAAgC,UAASP,IAAT,EAAc;AAC5C,MAAIQ,KAAK,GAAG,KAAKX,KAAL,CAAWY,OAAX,CAAmBT,IAAnB,CAAZ;AACA,MAAIQ,KAAK,KAAK,CAAC,CAAf,EAAkB,MAAM,4BAAN;AAClB,OAAKX,KAAL,CAAWa,MAAX,CAAkBF,KAAlB,EAAyB,CAAzB;AACD,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAf,QAAQ,CAACK,SAAT,CAAmBa,cAAnB,GAAoC,UAAUC,IAAV,EAAgBC,QAAhB,EAA0B;AAC5D,MAAIjB,UAAU,GAAG,KAAKA,UAAtB;AAAA,MACEI,IAAI,GAAG,UAAUG,KAAV,EAAiB;AACtB,QAAIW,YAAJ,EAAkBR,CAAlB,EAAqBS,GAArB;AACAD,IAAAA,YAAY,GAAIF,IAAI,IAAI,OAAT,GAAoB,CAACT,KAAD,CAApB,GAA+BA,KAAK,CAACS,IAAI,GAAG,GAAR,CAAL,IAAqB,EAAnE;;AAEA,SAAKN,CAAC,GAAG,CAAJ,EAAOS,GAAG,GAAGD,YAAY,CAACT,MAA/B,EAAuCC,CAAC,GAAGS,GAA3C,EAAgDT,CAAC,EAAjD,EAAqD;AACnDO,MAAAA,QAAQ,CAACG,IAAT,CAAcpB,UAAd,EAA0BkB,YAAY,CAACR,CAAD,CAAtC;AACD;;AAED,WAAOH,KAAP;AACD,GAVH;;AAYA,OAAKJ,OAAL,CAAaC,IAAb;AACA,SAAOA,IAAP;AACD,CAfD","sourcesContent":["var Pipeline = module.exports = function (controller) {\n  this.steps = [];\n  this.controller = controller;\n}\n\nPipeline.prototype.addStep = function (step) {\n  this.steps.push(step);\n}\n\nPipeline.prototype.run = function (frame) {\n  var stepsLength = this.steps.length;\n  for (var i = 0; i != stepsLength; i++) {\n    if (!frame) break;\n    frame = this.steps[i](frame);\n  }\n  return frame;\n}\n\nPipeline.prototype.removeStep = function(step){\n  var index = this.steps.indexOf(step);\n  if (index === -1) throw \"Step not found in pipeline\";\n  this.steps.splice(index, 1);\n}\n\n/*\n * Wraps a plugin callback method in method which can be run inside the pipeline.\n * This wrapper method loops the callback over objects within the frame as is appropriate,\n * calling the callback for each in turn.\n *\n * @method createStepFunction\n * @memberOf Leap.Controller.prototype\n * @param {Controller} The controller on which the callback is called.\n * @param {String} type What frame object the callback is run for and receives.\n *       Can be one of 'frame', 'finger', 'hand', 'pointable'\n * @param {function} callback The method which will be run inside the pipeline loop.  Receives one argument, such as a hand.\n * @private\n */\nPipeline.prototype.addWrappedStep = function (type, callback) {\n  var controller = this.controller,\n    step = function (frame) {\n      var dependencies, i, len;\n      dependencies = (type == 'frame') ? [frame] : (frame[type + 's'] || []);\n\n      for (i = 0, len = dependencies.length; i < len; i++) {\n        callback.call(controller, dependencies[i]);\n      }\n\n      return frame;\n    };\n\n  this.addStep(step);\n  return step;\n};"]},"metadata":{},"sourceType":"script"}