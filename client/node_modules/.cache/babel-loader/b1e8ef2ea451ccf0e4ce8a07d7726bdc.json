{"ast":null,"code":"var Pointable = require(\"./pointable\"),\n    Bone = require('./bone'),\n    glMatrix = require(\"gl-matrix\"),\n    mat3 = glMatrix.mat3,\n    vec3 = glMatrix.vec3;\n/**\n * Constructs a Hand object.\n *\n * An uninitialized hand is considered invalid.\n * Get valid Hand objects from a Frame object.\n * @class Hand\n * @memberof Leap\n * @classdesc\n * The Hand class reports the physical characteristics of a detected hand.\n *\n * Hand tracking data includes a palm position and velocity; vectors for\n * the palm normal and direction to the fingers; properties of a sphere fit\n * to the hand; and lists of the attached fingers.\n *\n * Note that Hand objects can be invalid, which means that they do not contain\n * valid tracking data and do not correspond to a physical entity. Invalid Hand\n * objects can be the result of asking for a Hand object using an ID from an\n * earlier frame when no Hand objects with that ID exist in the current frame.\n * A Hand object created from the Hand constructor is also invalid.\n * Test for validity with the [Hand.valid]{@link Leap.Hand#valid} property.\n */\n\n\nvar Hand = module.exports = function (data) {\n  /**\n   * A unique ID assigned to this Hand object, whose value remains the same\n   * across consecutive frames while the tracked hand remains visible. If\n   * tracking is lost (for example, when a hand is occluded by another hand\n   * or when it is withdrawn from or reaches the edge of the Leap field of view),\n   * the Leap may assign a new ID when it detects the hand in a future frame.\n   *\n   * Use the ID value with the {@link Frame.hand}() function to find this\n   * Hand object in future frames.\n   *\n   * @member id\n   * @memberof Leap.Hand.prototype\n   * @type {String}\n   */\n  this.id = data.id;\n  /**\n   * The center position of the palm in millimeters from the Leap origin.\n   * @member palmPosition\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n\n  this.palmPosition = data.palmPosition;\n  /**\n   * The direction from the palm position toward the fingers.\n   *\n   * The direction is expressed as a unit vector pointing in the same\n   * direction as the directed line from the palm position to the fingers.\n   *\n   * @member direction\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n\n  this.direction = data.direction;\n  /**\n   * The rate of change of the palm position in millimeters/second.\n   *\n   * @member palmVeclocity\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n\n  this.palmVelocity = data.palmVelocity;\n  /**\n   * The normal vector to the palm. If your hand is flat, this vector will\n   * point downward, or \"out\" of the front surface of your palm.\n   *\n   * ![Palm Vectors](images/Leap_Palm_Vectors.png)\n   *\n   * The direction is expressed as a unit vector pointing in the same\n   * direction as the palm normal (that is, a vector orthogonal to the palm).\n   * @member palmNormal\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n\n  this.palmNormal = data.palmNormal;\n  /**\n   * The center of a sphere fit to the curvature of this hand.\n   *\n   * This sphere is placed roughly as if the hand were holding a ball.\n   *\n   * ![Hand Ball](images/Leap_Hand_Ball.png)\n   * @member sphereCenter\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n\n  this.sphereCenter = data.sphereCenter;\n  /**\n   * The radius of a sphere fit to the curvature of this hand, in millimeters.\n   *\n   * This sphere is placed roughly as if the hand were holding a ball. Thus the\n   * size of the sphere decreases as the fingers are curled into a fist.\n   *\n   * @member sphereRadius\n   * @memberof Leap.Hand.prototype\n   * @type {number}\n   */\n\n  this.sphereRadius = data.sphereRadius;\n  /**\n   * Reports whether this is a valid Hand object.\n   *\n   * @member valid\n   * @memberof Leap.Hand.prototype\n   * @type {boolean}\n   */\n\n  this.valid = true;\n  /**\n   * The list of Pointable objects (fingers) detected in this frame\n   * that are associated with this hand, given in arbitrary order. The list\n   * can be empty if no fingers or tools associated with this hand are detected.\n   *\n   * Use the {@link Pointable} tool property to determine\n   * whether or not an item in the list represents a tool or finger.\n   * You can also get only the fingers using the Hand.fingers[] list.\n   *\n   * @member pointables[]\n   * @memberof Leap.Hand.prototype\n   * @type {Leap.Pointable[]}\n   */\n\n  this.pointables = [];\n  /**\n   * The list of fingers detected in this frame that are attached to\n   * this hand, given in arbitrary order.\n   *\n   * The list can be empty if no fingers attached to this hand are detected.\n   *\n   * @member fingers[]\n   * @memberof Leap.Hand.prototype\n   * @type {Leap.Pointable[]}\n   */\n\n  this.fingers = [];\n\n  if (data.armBasis) {\n    this.arm = new Bone(this, {\n      type: 4,\n      width: data.armWidth,\n      prevJoint: data.elbow,\n      nextJoint: data.wrist,\n      basis: data.armBasis\n    });\n  } else {\n    this.arm = null;\n  }\n\n  this._translation = data.t;\n\n  function flattenDeep(arr) {\n    return Array.isArray(arr) ? arr.reduce(function (a, b) {\n      return a.concat(flattenDeep(b));\n    }, []) : [arr];\n  }\n\n  this._rotation = flattenDeep(data.r);\n  this._scaleFactor = data.s;\n  /**\n   * Time the hand has been visible in seconds.\n   *\n   * @member timeVisible\n   * @memberof Leap.Hand.prototype\n   * @type {number}\n   */\n\n  this.timeVisible = data.timeVisible;\n  /**\n   * The palm position with stabalization\n   * @member stabilizedPalmPosition\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n\n  this.stabilizedPalmPosition = data.stabilizedPalmPosition;\n  /**\n  * Reports whether this is a left or a right hand.\n  *\n  * @member type\n  * @type {String}\n  * @memberof Leap.Hand.prototype\n  */\n\n  this.type = data.type;\n  this.grabStrength = data.grabStrength;\n  this.pinchStrength = data.pinchStrength;\n  this.confidence = data.confidence;\n};\n/**\n * The finger with the specified ID attached to this hand.\n *\n * Use this function to retrieve a Pointable object representing a finger\n * attached to this hand using an ID value obtained from a previous frame.\n * This function always returns a Pointable object, but if no finger\n * with the specified ID is present, an invalid Pointable object is returned.\n *\n * Note that the ID values assigned to fingers persist across frames, but only\n * until tracking of a particular finger is lost. If tracking of a finger is\n * lost and subsequently regained, the new Finger object representing that\n * finger may have a different ID than that representing the finger in an\n * earlier frame.\n *\n * @method finger\n * @memberof Leap.Hand.prototype\n * @param {String} id The ID value of a finger from a previous frame.\n * @returns {Leap.Pointable} The Finger object with\n * the matching ID if one exists for this hand in this frame; otherwise, an\n * invalid Finger object is returned.\n */\n\n\nHand.prototype.finger = function (id) {\n  var finger = this.frame.finger(id);\n  return finger && finger.handId == this.id ? finger : Pointable.Invalid;\n};\n/**\n * The angle of rotation around the rotation axis derived from the change in\n * orientation of this hand, and any associated fingers, between the\n * current frame and the specified frame.\n *\n * The returned angle is expressed in radians measured clockwise around the\n * rotation axis (using the right-hand rule) between the start and end frames.\n * The value is always between 0 and pi radians (0 and 180 degrees).\n *\n * If a corresponding Hand object is not found in sinceFrame, or if either\n * this frame or sinceFrame are invalid Frame objects, then the angle of rotation is zero.\n *\n * @method rotationAngle\n * @memberof Leap.Hand.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @param {numnber[]} [axis] The axis to measure rotation around.\n * @returns {number} A positive value representing the heuristically determined\n * rotational change of the hand between the current frame and that specified in\n * the sinceFrame parameter.\n */\n\n\nHand.prototype.rotationAngle = function (sinceFrame, axis) {\n  if (!this.valid || !sinceFrame.valid) return 0.0;\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return 0.0;\n  var rot = this.rotationMatrix(sinceFrame);\n  var cs = (rot[0] + rot[4] + rot[8] - 1.0) * 0.5;\n  var angle = Math.acos(cs);\n  angle = isNaN(angle) ? 0.0 : angle;\n\n  if (axis !== undefined) {\n    var rotAxis = this.rotationAxis(sinceFrame);\n    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));\n  }\n\n  return angle;\n};\n/**\n * The axis of rotation derived from the change in orientation of this hand, and\n * any associated fingers, between the current frame and the specified frame.\n *\n * The returned direction vector is normalized.\n *\n * If a corresponding Hand object is not found in sinceFrame, or if either\n * this frame or sinceFrame are invalid Frame objects, then this method returns a zero vector.\n *\n * @method rotationAxis\n * @memberof Leap.Hand.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @returns {number[]} A normalized direction Vector representing the axis of the heuristically determined\n * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.\n */\n\n\nHand.prototype.rotationAxis = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return vec3.create();\n  return vec3.normalize(vec3.create(), [this._rotation[7] - sinceHand._rotation[5], this._rotation[2] - sinceHand._rotation[6], this._rotation[3] - sinceHand._rotation[1]]);\n};\n/**\n * The transform matrix expressing the rotation derived from the change in\n * orientation of this hand, and any associated fingers, between\n * the current frame and the specified frame.\n *\n * If a corresponding Hand object is not found in sinceFrame, or if either\n * this frame or sinceFrame are invalid Frame objects, then this method returns\n * an identity matrix.\n *\n * @method rotationMatrix\n * @memberof Leap.Hand.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @returns {number[]} A transformation Matrix containing the heuristically determined\n * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.\n */\n\n\nHand.prototype.rotationMatrix = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return mat3.create();\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return mat3.create();\n  var transpose = mat3.transpose(mat3.create(), this._rotation);\n  var m = mat3.multiply(mat3.create(), sinceHand._rotation, transpose);\n  return m;\n};\n/**\n * The scale factor derived from the hand's motion between the current frame and the specified frame.\n *\n * The scale factor is always positive. A value of 1.0 indicates no scaling took place.\n * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.\n *\n * The Leap derives scaling from the relative inward or outward motion of a hand\n * and its associated fingers (independent of translation and rotation).\n *\n * If a corresponding Hand object is not found in sinceFrame, or if either this frame or sinceFrame\n * are invalid Frame objects, then this method returns 1.0.\n *\n * @method scaleFactor\n * @memberof Leap.Hand.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.\n * @returns {number} A positive value representing the heuristically determined\n * scaling change ratio of the hand between the current frame and that specified in the sinceFrame parameter.\n */\n\n\nHand.prototype.scaleFactor = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return 1.0;\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return 1.0;\n  return Math.exp(this._scaleFactor - sinceHand._scaleFactor);\n};\n/**\n * The change of position of this hand between the current frame and the specified frame\n *\n * The returned translation vector provides the magnitude and direction of the\n * movement in millimeters.\n *\n * If a corresponding Hand object is not found in sinceFrame, or if either this frame or\n * sinceFrame are invalid Frame objects, then this method returns a zero vector.\n *\n * @method translation\n * @memberof Leap.Hand.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.\n * @returns {number[]} A Vector representing the heuristically determined change in hand\n * position between the current frame and that specified in the sinceFrame parameter.\n */\n\n\nHand.prototype.translation = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return vec3.create();\n  return [this._translation[0] - sinceHand._translation[0], this._translation[1] - sinceHand._translation[1], this._translation[2] - sinceHand._translation[2]];\n};\n/**\n * A string containing a brief, human readable description of the Hand object.\n * @method toString\n * @memberof Leap.Hand.prototype\n * @returns {String} A description of the Hand as a string.\n */\n\n\nHand.prototype.toString = function () {\n  return \"Hand (\" + this.type + \") [ id: \" + this.id + \" | palm velocity:\" + this.palmVelocity + \" | sphere center:\" + this.sphereCenter + \" ] \";\n};\n/**\n * The pitch angle in radians.\n *\n * Pitch is the angle between the negative z-axis and the projection of\n * the vector onto the y-z plane. In other words, pitch represents rotation\n * around the x-axis.\n * If the vector points upward, the returned angle is between 0 and pi radians\n * (180 degrees); if it points downward, the angle is between 0 and -pi radians.\n *\n * @method pitch\n * @memberof Leap.Hand.prototype\n * @returns {number} The angle of this vector above or below the horizon (x-z plane).\n *\n */\n\n\nHand.prototype.pitch = function () {\n  return Math.atan2(this.direction[1], -this.direction[2]);\n};\n/**\n *  The yaw angle in radians.\n *\n * Yaw is the angle between the negative z-axis and the projection of\n * the vector onto the x-z plane. In other words, yaw represents rotation\n * around the y-axis. If the vector points to the right of the negative z-axis,\n * then the returned angle is between 0 and pi radians (180 degrees);\n * if it points to the left, the angle is between 0 and -pi radians.\n *\n * @method yaw\n * @memberof Leap.Hand.prototype\n * @returns {number} The angle of this vector to the right or left of the y-axis.\n *\n */\n\n\nHand.prototype.yaw = function () {\n  return Math.atan2(this.direction[0], -this.direction[2]);\n};\n/**\n *  The roll angle in radians.\n *\n * Roll is the angle between the y-axis and the projection of\n * the vector onto the x-y plane. In other words, roll represents rotation\n * around the z-axis. If the vector points to the left of the y-axis,\n * then the returned angle is between 0 and pi radians (180 degrees);\n * if it points to the right, the angle is between 0 and -pi radians.\n *\n * @method roll\n * @memberof Leap.Hand.prototype\n * @returns {number} The angle of this vector to the right or left of the y-axis.\n *\n */\n\n\nHand.prototype.roll = function () {\n  return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);\n};\n/**\n * An invalid Hand object.\n *\n * You can use an invalid Hand object in comparisons testing\n * whether a given Hand instance is valid or invalid. (You can also use the\n * Hand valid property.)\n *\n * @static\n * @type {Leap.Hand}\n * @name Invalid\n * @memberof Leap.Hand\n */\n\n\nHand.Invalid = {\n  valid: false,\n  fingers: [],\n  pointables: [],\n  left: false,\n  pointable: function () {\n    return Pointable.Invalid;\n  },\n  finger: function () {\n    return Pointable.Invalid;\n  },\n  toString: function () {\n    return \"invalid frame\";\n  },\n  dump: function () {\n    return this.toString();\n  },\n  rotationAngle: function () {\n    return 0.0;\n  },\n  rotationMatrix: function () {\n    return mat3.create();\n  },\n  rotationAxis: function () {\n    return vec3.create();\n  },\n  scaleFactor: function () {\n    return 1.0;\n  },\n  translation: function () {\n    return vec3.create();\n  }\n};","map":{"version":3,"sources":["/Users/stevdiaz/Desktop/MIT SPRING 2021/6835/6835Final/pic/node_modules/leapjs/lib/hand.js"],"names":["Pointable","require","Bone","glMatrix","mat3","vec3","Hand","module","exports","data","id","palmPosition","direction","palmVelocity","palmNormal","sphereCenter","sphereRadius","valid","pointables","fingers","armBasis","arm","type","width","armWidth","prevJoint","elbow","nextJoint","wrist","basis","_translation","t","flattenDeep","arr","Array","isArray","reduce","a","b","concat","_rotation","r","_scaleFactor","s","timeVisible","stabilizedPalmPosition","grabStrength","pinchStrength","confidence","prototype","finger","frame","handId","Invalid","rotationAngle","sinceFrame","axis","sinceHand","hand","rot","rotationMatrix","cs","angle","Math","acos","isNaN","undefined","rotAxis","rotationAxis","dot","normalize","create","transpose","m","multiply","scaleFactor","exp","translation","toString","pitch","atan2","yaw","roll","left","pointable","dump"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,OAAO,CAAC,aAAD,CAAvB;AAAA,IACIC,IAAI,GAAGD,OAAO,CAAC,QAAD,CADlB;AAAA,IAEIE,QAAQ,GAAGF,OAAO,CAAC,WAAD,CAFtB;AAAA,IAGIG,IAAI,GAAGD,QAAQ,CAACC,IAHpB;AAAA,IAIIC,IAAI,GAAGF,QAAQ,CAACE,IAJpB;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,IAAI,GAAGC,MAAM,CAACC,OAAP,GAAiB,UAASC,IAAT,EAAe;AACzC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,OAAKC,EAAL,GAAUD,IAAI,CAACC,EAAf;AACA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,YAAL,GAAoBF,IAAI,CAACE,YAAzB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,SAAL,GAAiBH,IAAI,CAACG,SAAtB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,YAAL,GAAoBJ,IAAI,CAACI,YAAzB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkBL,IAAI,CAACK,UAAvB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,YAAL,GAAoBN,IAAI,CAACM,YAAzB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,YAAL,GAAoBP,IAAI,CAACO,YAAzB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,KAAL,GAAa,IAAb;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkB,EAAlB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;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","sourcesContent":["var Pointable = require(\"./pointable\")\n  , Bone = require('./bone')\n  , glMatrix = require(\"gl-matrix\")\n  , mat3 = glMatrix.mat3\n  , vec3 = glMatrix.vec3;\n\n/**\n * Constructs a Hand object.\n *\n * An uninitialized hand is considered invalid.\n * Get valid Hand objects from a Frame object.\n * @class Hand\n * @memberof Leap\n * @classdesc\n * The Hand class reports the physical characteristics of a detected hand.\n *\n * Hand tracking data includes a palm position and velocity; vectors for\n * the palm normal and direction to the fingers; properties of a sphere fit\n * to the hand; and lists of the attached fingers.\n *\n * Note that Hand objects can be invalid, which means that they do not contain\n * valid tracking data and do not correspond to a physical entity. Invalid Hand\n * objects can be the result of asking for a Hand object using an ID from an\n * earlier frame when no Hand objects with that ID exist in the current frame.\n * A Hand object created from the Hand constructor is also invalid.\n * Test for validity with the [Hand.valid]{@link Leap.Hand#valid} property.\n */\nvar Hand = module.exports = function(data) {\n  /**\n   * A unique ID assigned to this Hand object, whose value remains the same\n   * across consecutive frames while the tracked hand remains visible. If\n   * tracking is lost (for example, when a hand is occluded by another hand\n   * or when it is withdrawn from or reaches the edge of the Leap field of view),\n   * the Leap may assign a new ID when it detects the hand in a future frame.\n   *\n   * Use the ID value with the {@link Frame.hand}() function to find this\n   * Hand object in future frames.\n   *\n   * @member id\n   * @memberof Leap.Hand.prototype\n   * @type {String}\n   */\n  this.id = data.id;\n  /**\n   * The center position of the palm in millimeters from the Leap origin.\n   * @member palmPosition\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n  this.palmPosition = data.palmPosition;\n  /**\n   * The direction from the palm position toward the fingers.\n   *\n   * The direction is expressed as a unit vector pointing in the same\n   * direction as the directed line from the palm position to the fingers.\n   *\n   * @member direction\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n  this.direction = data.direction;\n  /**\n   * The rate of change of the palm position in millimeters/second.\n   *\n   * @member palmVeclocity\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n  this.palmVelocity = data.palmVelocity;\n  /**\n   * The normal vector to the palm. If your hand is flat, this vector will\n   * point downward, or \"out\" of the front surface of your palm.\n   *\n   * ![Palm Vectors](images/Leap_Palm_Vectors.png)\n   *\n   * The direction is expressed as a unit vector pointing in the same\n   * direction as the palm normal (that is, a vector orthogonal to the palm).\n   * @member palmNormal\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n  this.palmNormal = data.palmNormal;\n  /**\n   * The center of a sphere fit to the curvature of this hand.\n   *\n   * This sphere is placed roughly as if the hand were holding a ball.\n   *\n   * ![Hand Ball](images/Leap_Hand_Ball.png)\n   * @member sphereCenter\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n  this.sphereCenter = data.sphereCenter;\n  /**\n   * The radius of a sphere fit to the curvature of this hand, in millimeters.\n   *\n   * This sphere is placed roughly as if the hand were holding a ball. Thus the\n   * size of the sphere decreases as the fingers are curled into a fist.\n   *\n   * @member sphereRadius\n   * @memberof Leap.Hand.prototype\n   * @type {number}\n   */\n  this.sphereRadius = data.sphereRadius;\n  /**\n   * Reports whether this is a valid Hand object.\n   *\n   * @member valid\n   * @memberof Leap.Hand.prototype\n   * @type {boolean}\n   */\n  this.valid = true;\n  /**\n   * The list of Pointable objects (fingers) detected in this frame\n   * that are associated with this hand, given in arbitrary order. The list\n   * can be empty if no fingers or tools associated with this hand are detected.\n   *\n   * Use the {@link Pointable} tool property to determine\n   * whether or not an item in the list represents a tool or finger.\n   * You can also get only the fingers using the Hand.fingers[] list.\n   *\n   * @member pointables[]\n   * @memberof Leap.Hand.prototype\n   * @type {Leap.Pointable[]}\n   */\n  this.pointables = [];\n  /**\n   * The list of fingers detected in this frame that are attached to\n   * this hand, given in arbitrary order.\n   *\n   * The list can be empty if no fingers attached to this hand are detected.\n   *\n   * @member fingers[]\n   * @memberof Leap.Hand.prototype\n   * @type {Leap.Pointable[]}\n   */\n  this.fingers = [];\n  \n  if (data.armBasis){\n    this.arm = new Bone(this, {\n      type: 4,\n      width: data.armWidth,\n      prevJoint: data.elbow,\n      nextJoint: data.wrist,\n      basis: data.armBasis\n    });\n  }else{\n    this.arm = null;\n  }\n  \n  this._translation = data.t;\n  function flattenDeep(arr) {\n    return Array.isArray(arr)\n      ? arr.reduce(function (a, b) { return a.concat(flattenDeep(b)) }, [])\n      : [arr];\n  }\n  this._rotation    = flattenDeep(data.r);\n  this._scaleFactor = data.s;\n\n  /**\n   * Time the hand has been visible in seconds.\n   *\n   * @member timeVisible\n   * @memberof Leap.Hand.prototype\n   * @type {number}\n   */\n   this.timeVisible = data.timeVisible;\n\n  /**\n   * The palm position with stabalization\n   * @member stabilizedPalmPosition\n   * @memberof Leap.Hand.prototype\n   * @type {number[]}\n   */\n   this.stabilizedPalmPosition = data.stabilizedPalmPosition;\n\n   /**\n   * Reports whether this is a left or a right hand.\n   *\n   * @member type\n   * @type {String}\n   * @memberof Leap.Hand.prototype\n   */\n   this.type = data.type;\n   this.grabStrength = data.grabStrength;\n   this.pinchStrength = data.pinchStrength;\n   this.confidence = data.confidence;\n}\n\n/**\n * The finger with the specified ID attached to this hand.\n *\n * Use this function to retrieve a Pointable object representing a finger\n * attached to this hand using an ID value obtained from a previous frame.\n * This function always returns a Pointable object, but if no finger\n * with the specified ID is present, an invalid Pointable object is returned.\n *\n * Note that the ID values assigned to fingers persist across frames, but only\n * until tracking of a particular finger is lost. If tracking of a finger is\n * lost and subsequently regained, the new Finger object representing that\n * finger may have a different ID than that representing the finger in an\n * earlier frame.\n *\n * @method finger\n * @memberof Leap.Hand.prototype\n * @param {String} id The ID value of a finger from a previous frame.\n * @returns {Leap.Pointable} The Finger object with\n * the matching ID if one exists for this hand in this frame; otherwise, an\n * invalid Finger object is returned.\n */\nHand.prototype.finger = function(id) {\n  var finger = this.frame.finger(id);\n  return (finger && (finger.handId == this.id)) ? finger : Pointable.Invalid;\n}\n\n/**\n * The angle of rotation around the rotation axis derived from the change in\n * orientation of this hand, and any associated fingers, between the\n * current frame and the specified frame.\n *\n * The returned angle is expressed in radians measured clockwise around the\n * rotation axis (using the right-hand rule) between the start and end frames.\n * The value is always between 0 and pi radians (0 and 180 degrees).\n *\n * If a corresponding Hand object is not found in sinceFrame, or if either\n * this frame or sinceFrame are invalid Frame objects, then the angle of rotation is zero.\n *\n * @method rotationAngle\n * @memberof Leap.Hand.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @param {numnber[]} [axis] The axis to measure rotation around.\n * @returns {number} A positive value representing the heuristically determined\n * rotational change of the hand between the current frame and that specified in\n * the sinceFrame parameter.\n */\nHand.prototype.rotationAngle = function(sinceFrame, axis) {\n  if (!this.valid || !sinceFrame.valid) return 0.0;\n  var sinceHand = sinceFrame.hand(this.id);\n  if(!sinceHand.valid) return 0.0;\n  var rot = this.rotationMatrix(sinceFrame);\n  var cs = (rot[0] + rot[4] + rot[8] - 1.0)*0.5\n  var angle = Math.acos(cs);\n  angle = isNaN(angle) ? 0.0 : angle;\n  if (axis !== undefined) {\n    var rotAxis = this.rotationAxis(sinceFrame);\n    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));\n  }\n  return angle;\n}\n\n/**\n * The axis of rotation derived from the change in orientation of this hand, and\n * any associated fingers, between the current frame and the specified frame.\n *\n * The returned direction vector is normalized.\n *\n * If a corresponding Hand object is not found in sinceFrame, or if either\n * this frame or sinceFrame are invalid Frame objects, then this method returns a zero vector.\n *\n * @method rotationAxis\n * @memberof Leap.Hand.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @returns {number[]} A normalized direction Vector representing the axis of the heuristically determined\n * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.\n */\nHand.prototype.rotationAxis = function(sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return vec3.create();\n  return vec3.normalize(vec3.create(), [\n    this._rotation[7] - sinceHand._rotation[5],\n    this._rotation[2] - sinceHand._rotation[6],\n    this._rotation[3] - sinceHand._rotation[1]\n  ]);\n}\n\n/**\n * The transform matrix expressing the rotation derived from the change in\n * orientation of this hand, and any associated fingers, between\n * the current frame and the specified frame.\n *\n * If a corresponding Hand object is not found in sinceFrame, or if either\n * this frame or sinceFrame are invalid Frame objects, then this method returns\n * an identity matrix.\n *\n * @method rotationMatrix\n * @memberof Leap.Hand.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\n * @returns {number[]} A transformation Matrix containing the heuristically determined\n * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.\n */\nHand.prototype.rotationMatrix = function(sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return mat3.create();\n  var sinceHand = sinceFrame.hand(this.id);\n  if(!sinceHand.valid) return mat3.create();\n  var transpose = mat3.transpose(mat3.create(), this._rotation);\n  var m = mat3.multiply(mat3.create(), sinceHand._rotation, transpose);\n  return m;\n}\n\n/**\n * The scale factor derived from the hand's motion between the current frame and the specified frame.\n *\n * The scale factor is always positive. A value of 1.0 indicates no scaling took place.\n * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.\n *\n * The Leap derives scaling from the relative inward or outward motion of a hand\n * and its associated fingers (independent of translation and rotation).\n *\n * If a corresponding Hand object is not found in sinceFrame, or if either this frame or sinceFrame\n * are invalid Frame objects, then this method returns 1.0.\n *\n * @method scaleFactor\n * @memberof Leap.Hand.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.\n * @returns {number} A positive value representing the heuristically determined\n * scaling change ratio of the hand between the current frame and that specified in the sinceFrame parameter.\n */\nHand.prototype.scaleFactor = function(sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return 1.0;\n  var sinceHand = sinceFrame.hand(this.id);\n  if(!sinceHand.valid) return 1.0;\n\n  return Math.exp(this._scaleFactor - sinceHand._scaleFactor);\n}\n\n/**\n * The change of position of this hand between the current frame and the specified frame\n *\n * The returned translation vector provides the magnitude and direction of the\n * movement in millimeters.\n *\n * If a corresponding Hand object is not found in sinceFrame, or if either this frame or\n * sinceFrame are invalid Frame objects, then this method returns a zero vector.\n *\n * @method translation\n * @memberof Leap.Hand.prototype\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.\n * @returns {number[]} A Vector representing the heuristically determined change in hand\n * position between the current frame and that specified in the sinceFrame parameter.\n */\nHand.prototype.translation = function(sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  var sinceHand = sinceFrame.hand(this.id);\n  if(!sinceHand.valid) return vec3.create();\n  return [\n    this._translation[0] - sinceHand._translation[0],\n    this._translation[1] - sinceHand._translation[1],\n    this._translation[2] - sinceHand._translation[2]\n  ];\n}\n\n/**\n * A string containing a brief, human readable description of the Hand object.\n * @method toString\n * @memberof Leap.Hand.prototype\n * @returns {String} A description of the Hand as a string.\n */\nHand.prototype.toString = function() {\n  return \"Hand (\" + this.type + \") [ id: \"+ this.id + \" | palm velocity:\"+this.palmVelocity+\" | sphere center:\"+this.sphereCenter+\" ] \";\n}\n\n/**\n * The pitch angle in radians.\n *\n * Pitch is the angle between the negative z-axis and the projection of\n * the vector onto the y-z plane. In other words, pitch represents rotation\n * around the x-axis.\n * If the vector points upward, the returned angle is between 0 and pi radians\n * (180 degrees); if it points downward, the angle is between 0 and -pi radians.\n *\n * @method pitch\n * @memberof Leap.Hand.prototype\n * @returns {number} The angle of this vector above or below the horizon (x-z plane).\n *\n */\nHand.prototype.pitch = function() {\n  return Math.atan2(this.direction[1], -this.direction[2]);\n}\n\n/**\n *  The yaw angle in radians.\n *\n * Yaw is the angle between the negative z-axis and the projection of\n * the vector onto the x-z plane. In other words, yaw represents rotation\n * around the y-axis. If the vector points to the right of the negative z-axis,\n * then the returned angle is between 0 and pi radians (180 degrees);\n * if it points to the left, the angle is between 0 and -pi radians.\n *\n * @method yaw\n * @memberof Leap.Hand.prototype\n * @returns {number} The angle of this vector to the right or left of the y-axis.\n *\n */\nHand.prototype.yaw = function() {\n  return Math.atan2(this.direction[0], -this.direction[2]);\n}\n\n/**\n *  The roll angle in radians.\n *\n * Roll is the angle between the y-axis and the projection of\n * the vector onto the x-y plane. In other words, roll represents rotation\n * around the z-axis. If the vector points to the left of the y-axis,\n * then the returned angle is between 0 and pi radians (180 degrees);\n * if it points to the right, the angle is between 0 and -pi radians.\n *\n * @method roll\n * @memberof Leap.Hand.prototype\n * @returns {number} The angle of this vector to the right or left of the y-axis.\n *\n */\nHand.prototype.roll = function() {\n  return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);\n}\n\n/**\n * An invalid Hand object.\n *\n * You can use an invalid Hand object in comparisons testing\n * whether a given Hand instance is valid or invalid. (You can also use the\n * Hand valid property.)\n *\n * @static\n * @type {Leap.Hand}\n * @name Invalid\n * @memberof Leap.Hand\n */\nHand.Invalid = {\n  valid: false,\n  fingers: [],\n  pointables: [],\n  left: false,\n  pointable: function() { return Pointable.Invalid },\n  finger: function() { return Pointable.Invalid },\n  toString: function() { return \"invalid frame\" },\n  dump: function() { return this.toString(); },\n  rotationAngle: function() { return 0.0; },\n  rotationMatrix: function() { return mat3.create(); },\n  rotationAxis: function() { return vec3.create(); },\n  scaleFactor: function() { return 1.0; },\n  translation: function() { return vec3.create(); }\n};\n"]},"metadata":{},"sourceType":"script"}